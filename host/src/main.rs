// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    GUEST_PROOFING_LOGIC_ELF, GUEST_PROOFING_LOGIC_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt,  ReceiptKind};
use serde::{Deserialize, Serialize};
//use serde::Serialize;

use base64::{engine::general_purpose, Engine as _};

use axum::{
    routing::get,
    routing::post, 
    Router,
    Json
};

    #[derive(Serialize)]
    struct ProofResponse {
    proof_receipt: String,
    journal_output: u32,
    image_id: String,
}


    #[derive(Serialize, Deserialize)]
    pub struct StoredData {
        pub receipt: Receipt,
        pub previous_id: [u32; 8],
    }


    #[derive(Deserialize, Serialize)]
struct ShipmentInfo {
    activity_data_json: String,
    activity_signature: String,
    activity_public_key_pem: String,
}

#[derive(Deserialize, Serialize)]
struct Shipment {
    shipment_id: String,
    info: ShipmentInfo,
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(|| async { "Hello, World!" }))
        .route("/proof", post(prove_plain_ad));

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn prove_plain_ad(Json(shipments): Json<Vec<Shipment>>) -> Json<ProofResponse> {
    // Initialize tracing (optional; remove if you initialize globally)
    let _ = tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .try_init();

    let env = ExecutorEnv::builder()
        .write(&shipments)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_PROOFING_LOGIC_ELF).unwrap();
    let receipt = prove_info.receipt;

    // Decode output from receipt journal
    let journal_output: u32 = receipt.journal.decode().unwrap();

    // Verify the receipt (optional here, but shows it works)
    receipt.verify(GUEST_PROOFING_LOGIC_ID).unwrap();

    // Serialize receipt (as base64-encoded bytes)
    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    let encoded_receipt = general_purpose::STANDARD.encode(receipt_bytes);

    Json(ProofResponse {
        proof_receipt: encoded_receipt,
        journal_output,
        image_id: format!("{:?}", GUEST_PROOFING_LOGIC_ID),
    })
}

